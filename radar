import os
from datetime import date, datetime
from fastapi import FastAPI, Request
from fastapi.responses import HTMLResponse, JSONResponse
from sqlalchemy import create_engine, text
from dotenv import load_dotenv

load_dotenv()
DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///policy_radar.db")
engine = create_engine(DATABASE_URL, future=True)

app = FastAPI(title="Policy Radar")

def effective_status(eff_date: str | None) -> str:
    if not eff_date:
        return "unknown"
    try:
        d = datetime.fromisoformat(eff_date).date()
    except Exception:
        return "unknown"
    today = date.today()
    if d <= today:
        return "active"
    elif (d - today).days <= 90:
        return "effective soon"
    else:
        return "scheduled"

@app.get("/bills")
def list_bills(topic: str = "", state: str = "", status: str = "", limit: int = 100):
    where = []
    params = {}
    if topic:
        where.append("EXISTS (SELECT 1 FROM labels l WHERE l.bill_uid=b.bill_uid AND l.topic_labels LIKE :topic)")
        params["topic"] = f"%{topic}%"
    if state:
        where.append("b.jurisdiction=:st")
        params["st"] = state
    if status:
        where.append("b.status_general=:sg")
        params["sg"] = status
    sql = f"""
        SELECT b.bill_uid, b.jurisdiction, b.bill_number, b.title, b.status_general, b.last_action_date,
               b.effective_date, COALESCE(l.topic_labels, '') AS topic_labels
        FROM bills b
        LEFT JOIN labels l ON l.bill_uid=b.bill_uid
        {"WHERE " + " AND ".join(where) if where else ""}
        ORDER BY b.updated_at DESC
        LIMIT :lim
    """
    params["lim"] = limit
    with engine.begin() as conn:
        rows = conn.execute(text(sql), params).mappings().all()
    data = []
    for r in rows:
        d = dict(r)
        d["effective_status"] = effective_status(d.get("effective_date"))
        data.append(d)
    return JSONResponse(data)

@app.get("/", response_class=HTMLResponse)
def dashboard(request: Request, topic: str = "", state: str = "", status: str = "", limit: int = 100, only_effective_soon: int = 0):
    base_sql = """
        SELECT b.bill_uid, b.jurisdiction, b.bill_number, b.title, b.status_general,
               b.last_action_date, b.effective_date, COALESCE(l.topic_labels, '') AS topic_labels
        FROM bills b
        LEFT JOIN labels l ON l.bill_uid=b.bill_uid
        ORDER BY b.updated_at DESC
        LIMIT :lim
    """
    with engine.begin() as conn:
        rows = conn.execute(text(base_sql), {"lim": limit}).mappings().all()

    items = []
    for r in rows:
        topics = (r["topic_labels"] or "").split(",") if r["topic_labels"] else []
        if topic and topic not in topics:
            continue
        if state and state != r["jurisdiction"]:
            continue
        if status and status != r["status_general"]:
            continue
        eff_stat = effective_status(r["effective_date"])
        if only_effective_soon and eff_stat not in ("effective soon", "active"):
            continue
        items.append((r, eff_stat))

    def selected(val, opt):
        return "selected" if str(val) == str(opt) else ""

    html = f"""
    <!doctype html>
    <html>
    <head>
        <meta charset="utf-8" />
        <title>Policy Radar</title>
        <style>
            body {{ font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 20px; }}
            h1 {{ margin-bottom: 8px; }}
            .filters {{ display: flex; gap: 10px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }}
            select, input[type=text], button {{ padding: 6px 8px; }}
            table {{ width: 100%; border-collapse: collapse; }}
            th, td {{ border-bottom: 1px solid #eee; padding: 8px; text-align: left; vertical-align: top; }}
            tr:hover {{ background: #fafafa; }}
            .tag {{ display: inline-block; padding: 2px 6px; border-radius: 6px; background: #f1f3f5; margin-right: 6px; font-size: 12px; }}
            .status {{ font-weight: 600; }}
            .pill {{ padding: 2px 6px; border-radius: 999px; font-size: 12px; }}
            .active {{ background: #e3f9e5; color: #046a38; }}
            .soon {{ background: #fff4e5; color: #8a4300; }}
            .unknown {{ background: #f1f3f5; color: #495057; }}
        </style>
    </head>
    <body>
        <h1>Policy Radar</h1>
        <form class="filters" method="get" action="/">
            <label>Topic
                <select name="topic">
                    <option value="" {selected(topic,"")}>All</option>
                    <option value="ai" {selected(topic,"ai")}>AI</option>
                    <option value="privacy" {selected(topic,"privacy")}>Privacy</option>
                    <option value="housing" {selected(topic,"housing")}>Housing</option>
                    <option value="healthcare" {selected(topic,"healthcare")}>Healthcare</option>
                </select>
            </label>
            <label>State
                <input type="text" name="state" value="{state}" placeholder="e.g., CA, New York" />
            </label>
            <label>Status
                <select name="status">
                    <option value="" {selected(status,"")}>Any</option>
                    <option value="INTRODUCED" {selected(status,"INTRODUCED")}>Introduced</option>
                    <option value="IN_COMMITTEE" {selected(status,"IN_COMMITTEE")}>In Committee</option>
                    <option value="REPORTED" {selected(status,"REPORTED")}>Reported</option>
                    <option value="ON_FLOOR" {selected(status,"ON_FLOOR")}>On Floor</option>
                    <option value="PASSED_LEGISLATURE" {selected(status,"PASSED_LEGISLATURE")}>Passed Legislature</option>
                    <option value="ENACTED" {selected(status,"ENACTED")}>Enacted</option>
                    <option value="VETOED" {selected(status,"VETOED")}>Vetoed</option>
                    <option value="FAILED_DEAD" {selected(status,"FAILED_DEAD")}>Failed/Dead</option>
                </select>
            </label>
            <label><input type="checkbox" name="only_effective_soon" value="1" { "checked" if only_effective_soon else "" }/> Only effective now/soon</label>
            <button type="submit">Apply</button>
        </form>

        <table>
            <thead>
                <tr>
                    <th>State</th>
                    <th>Bill</th>
                    <th>Title</th>
                    <th>Status</th>
                    <th>Last Action</th>
                    <th>Effective</th>
                    <th>Topics</th>
                </tr>
            </thead>
            <tbody>
    """

    for r, eff_stat in items:
        pill_class = "active" if eff_stat == "active" else ("soon" if eff_stat == "effective soon" else "unknown")
        eff_label = r["effective_date"] or "—"
        topics_html = "".join(f'<span class="tag">{t}</span>' for t in (r["topic_labels"] or "").split(",") if t)
        html += f"""
            <tr>
                <td>{r["jurisdiction"] or ""}</td>
                <td>{r["bill_number"] or ""}</td>
                <td>{(r["title"] or "")[:140]}</td>
                <td class="status">{r["status_general"] or ""}</td>
                <td>{r["last_action_date"] or ""}</td>
                <td><span class="pill {pill_class}">{eff_label}</span></td>
                <td>{topics_html}</td>
            </tr>
        """

    html += """
            </tbody>
        </table>
        <p style="margin-top:12px;color:#666;font-size:12px;">Tip: filter by two-letter postal (e.g., CA) or full state name (e.g., California).</p>
    </body>
    </html>
    """
    return HTMLResponse(html)

python-dotenv==1.0.1
requests==2.32.3
SQLAlchemy==2.0.32
psycopg2-binary==2.9.9
fastapi==0.115.0
uvicorn==0.30.6
pydantic==2.9.2

\
from datetime import datetime
from typing import Dict, Any, List

CLASSIFY_MAP = {
    "introduced": "INTRODUCED",
    "referral": "IN_COMMITTEE",
    "committee-referral": "IN_COMMITTEE",
    "committee-passage": "REPORTED",
    "committee-passage-favorable": "REPORTED",
    "reading-1": "ON_FLOOR",
    "reading-2": "ON_FLOOR",
    "reading-3": "ON_FLOOR",
    "floor-passage": "ON_FLOOR",
    "passage": "PASSED_CHAMBER",
    "executive-signature": "ENACTED",
    "enacted": "ENACTED",
    "chaptered": "ENACTED",
    "veto": "VETOED",
}

def derive_status_general(actions: List[Dict[str, Any]]) -> str:
    # Coarse heuristic: last-most-significant classification wins
    order = [
        "VETOED", "ENACTED", "PASSED_LEGISLATURE",
        "ON_FLOOR", "REPORTED", "IN_COMMITTEE", "INTRODUCED"
    ]
    seen = set()
    for a in sorted(actions, key=lambda x: x.get("action_date","")):
        for c in a.get("classification", []):
            mapped = CLASSIFY_MAP.get(c)
            if mapped:
                if mapped == "PASSED_CHAMBER":
                    seen.add(mapped)
                    if "PASSED_CHAMBER" in seen and len([1 for s in actions if "passage" in s.get("classification",[])]) >= 2:
                        return "PASSED_LEGISLATURE"
                else:
                    last = mapped
    return last if (last := locals().get("last")) else "INTRODUCED"

def normalize_openstates_bill(b: Dict[str, Any]) -> Dict[str, Any]:
    bill_uid = f"openstates:{b['id']}"
    jurisdiction = b.get("jurisdiction", {}).get("name")
    session = b.get("from_session")
    bill_number = b.get("identifier")
    title = b.get("title")
    summary = b.get("summary")
    subjects = ",".join(b.get("subject", []) or [])
    sponsors = b.get("sponsorships", [])
    sponsor_primary = ""
    for s in sponsors:
        if s.get("primary"):
            sponsor_primary = s.get("name") or s.get("person", {}).get("name") or ""
            break
    committees = []
    for a in b.get("actions", []):
        org = a.get("organization", {}).get("name") or ""
        if org and org not in committees:
            committees.append(org)
    actions_norm = []
    for a in b.get("actions", []):
        actions_norm.append({
            "action_date": a.get("date"),
            "organization": a.get("organization", {}).get("name"),
            "classification": a.get("classification", []),
            "action_text": a.get("description")
        })
    status_general = derive_status_general(actions_norm) if actions_norm else "INTRODUCED"
    introduced_date = None
    if b.get("first_action_date"):
        introduced_date = b.get("first_action_date")
    last_action_date = b.get("latest_action_date") or (actions_norm[-1]["action_date"] if actions_norm else None)
    return {
        "bill": {
            "bill_uid": bill_uid,
            "source": "openstates",
            "jurisdiction": jurisdiction,
            "session": session,
            "bill_number": bill_number,
            "title": title,
            "summary": summary,
            "subjects": subjects,
            "sponsors_primary": sponsor_primary,
            "committees": ",".join(committees[:10]),
            "status_general": status_general,
            "status_specific": "",
            "introduced_date": introduced_date,
            "effective_date": None,
            "last_action_date": last_action_date,
            "updated_at": datetime.utcnow().isoformat()
        },
        "actions": actions_norm
    }
\
import os, hashlib
from sqlalchemy import create_engine, text
from sqlalchemy.engine import Engine
from dotenv import load_dotenv

load_dotenv()

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///policy_radar.db")

SCHEMA_SQL = """
CREATE TABLE IF NOT EXISTS bills (
  bill_uid TEXT PRIMARY KEY,
  source TEXT NOT NULL,
  jurisdiction TEXT,
  session TEXT,
  bill_number TEXT,
  title TEXT,
  summary TEXT,
  subjects TEXT,
  sponsors_primary TEXT,
  committees TEXT,
  status_general TEXT,
  status_specific TEXT,
  introduced_date TEXT,
  effective_date TEXT,
  last_action_date TEXT,
  updated_at TEXT
);


\
import os, argparse, hashlib, requests, math
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv
from sqlalchemy import text
from db import get_engine, upsert_bill, upsert_action, set_labels
from normalize import normalize_openstates_bill
from classify import label_record
from alerts import send_slack

load_dotenv()

OPENSTATES_API_KEY = os.getenv("be79973d-628b-4f4a-b771-ce40dc6791c0")
DEFAULT_SINCE_DAYS = int(os.getenv("DEFAULT_SINCE_DAYS", "2"))
DEFAULT_QUERY = os.getenv("DEFAULT_QUERY", "artificial intelligence OR generative OR privacy")
DEFAULT_STATES = [s.strip() for s in os.getenv("DEFAULT_STATES","CA,NY").split(",")]
DRY_RUN = os.getenv("DRY_RUN","0") == "1"

BASE_URL = "https://v3.openstates.org/bills"

def openstates_get(params):
    headers = {"X-API-KEY": OPENSTATES_API_KEY}
    r = requests.get(BASE_URL, params=params, headers=headers, timeout=30)
    r.raise_for_status()
    return r.json()

def hash_action(bill_uid, a):
    s = f"{bill_uid}|{a.get('action_date')}|{a.get('organization')}|{','.join(a.get('classification',[]))}|{a.get('action_text')}"
    return hashlib.sha256(s.encode("utf-8")).hexdigest()

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--since", help="ISO8601 date (YYYY-MM-DD) to use for updated_since")
    parser.add_argument("--state", action="append", help="State name or postal (e.g., CA). Repeatable.")
    parser.add_argument("--q", help="Search query string")
    args = parser.parse_args()

    if not OPENSTATES_API_KEY:
        raise SystemExit(be79973d-628b-4f4a-b771-ce40dc6791c0)

    since = args.since or (datetime.now(timezone.utc) - timedelta(days=DEFAULT_SINCE_DAYS)).date().isoformat()
    q = args.q or DEFAULT_QUERY
    states = args.state or DEFAULT_STATES

    engine = get_engine()
    total_new_status = 0

    for st in states:
        page = 1
        while True:
            params = {
                "q": q,
                "jurisdiction": st,
                "updated_since": since,
                "sort": "updated_at",
                "per_page": 50,
                "page": page,
                "include": "sponsorships,actions,subject,related_bills"
            }
            data = openstates_get(params)
            results = data.get("results", [])
            if not results:
                break

            with engine.begin() as conn:
                for b in results:
                    pack = normalize_openstates_bill(b)
                    bill = pack["bill"]
                    actions = pack["actions"]
                    # Detect old status to decide if we alert
                    old_status = conn.execute(text("SELECT status_general FROM bills WHERE bill_uid=:u"), {"u": bill["bill_uid"]}).scalar()
                    upsert_bill(conn, bill)

                    # Insert actions idempotently
                    for a in actions:
                        aid = hash_action(bill["bill_uid"], a)
                        upsert_action(conn, {
                            "id": aid,
                            "bill_uid": bill["bill_uid"],
                            "action_date": a.get("action_date"),
                            "organization": a.get("organization"),
                            "classification": ",".join(a.get("classification", [])),
                            "action_text": a.get("action_text"),
                        })

                    # Labels
                    labels = label_record(" ".join([bill.get("title") or "", bill.get("summary") or ""]))
                    topics = [k for k,v in labels.items() if v]
                    set_labels(conn, {
                        "bill_uid": bill["bill_uid"],
                        "topic_labels": ",".join(topics),
                        "client_vertical": "property_mgmt,healthcare" if ("housing" in topics or "healthcare" in topics) else "",
                        "impact_score": 50 if ("ai" in topics or "privacy" in topics) else 20
                    })

                    # Alert on meaningful status change
                    new_status = bill["status_general"]
                    if new_status and new_status != (old_status or ""):
                        total_new_status += 1
                        if not DRY_RUN:
                            msg = f"*{bill['bill_number']}* · {bill['title']}\nState: {bill['jurisdiction']}  •  Status: *{new_status}*\nUpdated: {bill['last_action_date']}"
                            blocks = [
                                {"type":"section","text":{"type":"mrkdwn","text":msg}},
                            ]
                            send_slack(msg, blocks=blocks)

            page += 1

    print(f"Done. Status changes alerted: {total_new_status}")

if __name__ == "__main__":
    main()

\
import re
from typing import Dict

AI_TERMS = [
    r"artificial intelligence", r"\balgorithmic\b", r"automated decision",
    r"\bdeepfake\b", r"synthetic media", r"\bgenerative\b", r"machine learning"
]

PRIVACY_TERMS = [
    r"consumer data privacy", r"\bbiometric\b", r"data broker",
    r"children'?s privacy", r"health data", r"data minimization", r"sensitive data"
]

HOUSING_TERMS = [
    r"tenant screening", r"rental application", r"\beviction\b", r"fair housing",
    r"rent cap", r"security deposit", r"habitability", r"source of income"
]

HEALTH_TERMS = [
    r"\btelehealth\b", r"\btelemedicine\b", r"prior authorization",
    r"utilization management", r"clinical decision support", r"health data", r"HIPAA"
]

def label_record(text: str) -> Dict[str, bool]:
    tx = (text or "").lower()
    def any_match(patterns):
        return any(re.search(p, tx) for p in patterns)
    return {
        "ai": any_match(AI_TERMS),
        "privacy": any_match(PRIVACY_TERMS),
        "housing": any_match(HOUSING_TERMS),
        "healthcare": any_match(HEALTH_TERMS),
    }

\
import os, json, requests
from dotenv import load_dotenv

load_dotenv()
SLACK_WEBHOOK_URL = os.getenv(https://app.slack.com/huddle/TFH2E6U3X/C09D6RPEAD8)

def send_slack(message: str, blocks=None):
    if not [Slack webhook](https://app.slack.com/huddle/TFH2E6U3X/C09D6RPEAD8):
        print("⚠️ No [Slack webhook](https://app.slack.com/huddle/TFH2E6U3X/C09D6RPEAD8) set; skipping Slack")
        return
    payload = {"text": message}
    if blocks:
        payload["blocks"] = blocks
    resp = requests.post([Slack webhook](https://app.slack.com/huddle/TFH2E6U3X/C09D6RPEAD8), json=payload, timeout=10)
    try:
        resp.raise_for_status()
    except Exception as e:
        print("Slack send failed:", e)


